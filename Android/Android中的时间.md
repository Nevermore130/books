#### System.currentTimeMillis() ####

一般通过它来获取手机系统的当前时间。事实上，它返回的值是系统时刻距离标准时刻(1970.01.01 00:00:00)的毫秒数。它相当于家里的“挂钟”一样，并不是十分精准，而且可以随意修改。所以它可能经常被网络或者用户校准。正是由于这个原因，这个方法获取的值**不适合用来做时间间隔的统计**。但是它适合用来获取当前日期，时刻等**时间点**相关的逻辑。

#### SystemClock.upTimeMillis() ####

这个值记录了系统启动到当前时刻经过的时间。但是系统深度睡眠(CPU睡眠，黑屏，系统等待唤醒)之中的时间不算在内。这个值不受系统时间设置，电源策略等因素的影响，因此它是大多数时间间隔统计的基础，例如`Thread.sleep(long millis)`,`Object.wait(long millis)`,`System.nanoTime()`等。系统保证了这个值只增长不下降，所以它适合所有的**不包括系统睡眠时间的时间间隔统计**。



#### SystemClock.elapsedRealtime() & SystemClock.elapsedRealtimeNanos ####

这个值与`SystemClock.upTimeMillis()`类似。它是系统启动到当前时刻经过的时间，包括了系统睡眠经过的时间。在CPU休眠之后，它依然保持增长。所以它适合做更加**广泛通用的时间间隔的统计**。

综上，如果想要避免用户修改时间，网络校准时间对时间间隔统计的影响，使用`SystemClock`类相关的方法就可以了，至于选择`upTimeMillis()`还是`elapsedRealtime()`就要根据自己的需求确定了。

